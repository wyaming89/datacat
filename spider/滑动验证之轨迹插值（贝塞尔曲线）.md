# 滑动验证之轨迹插值（贝塞尔曲线）

在过某验的滑动验证时，由于某验的后台是通过环境及轨迹数据进行机器学习预测判断是否是机器人，所以不管是使用selenium还是js逆向，都需要做轨迹模拟，在一位大佬的文章看到用缓动函数来模拟轨迹，试过效果不错。这里将缓动函数中的贝塞尔曲线做个学习记录。

## 缓动函数

缓动函数在ccs动画中经常用到，缓动函数是通过时间的变化控制参数值变化的速率。物体并不是突然启动或者停止，当然也不可能一直保持匀速移动。就像我们打开抽屉的过程那样，刚开始拉的那一下动作很快，但是当抽屉被拉出来之后我们会不自觉的放慢动作。掉落在地板上的东西，一开始下降的速度很快，后来就会在地板上来回反弹直到停止。

主要的缓动函数

![image-20200910170526829](https://cosming-1257343076.cos.ap-guangzhou.myqcloud.com/img/image-20200910170526829.png)

可以在这个网站（https://cubic-bezier.com/）可视化编辑缓动函数，像PPT动画的不少效果也是这种缓动函数的效果。缓动函数模拟的是事物运动或变换过程的变化率。

![ease](https://cosming-1257343076.cos.ap-guangzhou.myqcloud.com/img/ease.gif)

## 贝塞尔曲线

### 线性曲线

线性贝塞尔曲线是经过$P_0$到$P_1$的$B(t)$函数的曲线，当只有两个点时，曲线是一条两点间的直线。公式：

$B(t) = P_0 + (P_1 - P_0)t = (1 - t)P_0 + tP_1, t\in [0, 1]$

![线性贝塞尔曲线演示动画，t在[0,1]区间](https://cosming-1257343076.cos.ap-guangzhou.myqcloud.com/img/240px-Bézier_1_big.gif)



### 二次方贝塞尔曲线

二次方贝塞尔曲线的路径有给定的 $P_0$、$ P_1$、$P_2$的函数$B(t)$追踪：

$B(t) = (1-t)^2P_0 + 2t(1-t)P_1 + t^2P_2, t \in [0,1]$ 

构建二次贝塞尔曲线是借助在$ P_0$与$P_1$，$P_1$与$P_2$线性贝塞尔曲线上的中介点$Q_0$、$Q_1$作为t

- 由$P_0$至$P_1$的连续点$Q_0$，描述一条线性贝塞尔曲线
- 由$P_1$至$P_2$的连续点$Q_1$，描述一条线性贝塞尔曲线
- 由$Q_0$至$Q_1$的连续点$B(t)$，描述一条二次贝塞尔曲线

![二次贝塞尔曲线演示动画，t in [0,1]](https://cosming-1257343076.cos.ap-guangzhou.myqcloud.com/img/240px-Bézier_2_big.gif)

### 三次方贝塞尔曲线

$P_0$、$P_1$、$P_2$、$P_3$四个点在平面或在三维空间中定义了三次方贝塞尔曲线。曲线起始于$P_0$走向$P_1$，并从$P_2$的方向来到$P_3$。一般不会经过$P_1$或$P_2$；这两个点只是在那里提供方向信息。$P_0$和$P_1$间的间距，决定了曲线在转而趋进$P_2$之前，走向$P_1$方向的“长度有多长”。这就刚好是我们要的缓动函数，确定起点终点，需要方向轨迹和速度。

$B(t) = P_0(1-t)^3 + 3P_1t(1-t)^2 + 3P_2t^2(1-t) + P_3t^3, t\in [0,1]$

![三次贝塞尔曲线演示动画，t in [0,1]](https://cosming-1257343076.cos.ap-guangzhou.myqcloud.com/img/240px-Bézier_3_big.gif)



### python实现

```python
def track_bezier(p1, p2, p3, p4, time, interval=0.1):
    """
    p1、p4是轨迹的起点终点；
    p2、p3控制方向
    time表示整个缓动时间长度
    interval是时间间隔
    """
    track = []
    for t in range(0, time, interval):
        x = p1[0]*pow((1-t),3) \
            + 3*p2[0]*t*pow((1-t),2) \
            + 3*p3[0]*pow(t,2)*(1-t)\
            +p4[0]*pow(t,3)
        y = p1[1]*pow((1-t),3) \
            + 3*p2[1]*t*pow((1-t),2) \
            + 3*p3[1]*pow(t,2)*(1-t)\
            +p4[1]*pow(t,3)
        track.append((x,y))

    return track
```

